// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// Code generated by cmd/codegen. DO NOT EDIT.

package ple

import (
	"iter"
	"maps"
	"strings"

	"github.com/lrstanley/go-nf"
)

var (
	allGlyphs = map[string]nf.Glyph{
		"backslash_separator":              BackslashSeparator,
		"backslash_separator_redundant":    BackslashSeparatorRedundant,
		"column_number":                    ColumnNumber,
		"current_column":                   CurrentColumn,
		"flame_thick":                      FlameThick,
		"flame_thick_mirrored":             FlameThickMirrored,
		"flame_thin":                       FlameThin,
		"flame_thin_mirrored":              FlameThinMirrored,
		"forwardslash_separator":           ForwardslashSeparator,
		"forwardslash_separator_redundant": ForwardslashSeparatorRedundant,
		"honeycomb":                        Honeycomb,
		"honeycomb_outline":                HoneycombOutline,
		"ice_waveform":                     IceWaveform,
		"ice_waveform_mirrored":            IceWaveformMirrored,
		"left_half_circle_thick":           LeftHalfCircleThick,
		"left_half_circle_thin":            LeftHalfCircleThin,
		"left_hard_divider_inverse":        LeftHardDividerInverse,
		"lego_block_facing":                LegoBlockFacing,
		"lego_block_sideways":              LegoBlockSideways,
		"lego_separator":                   LegoSeparator,
		"lego_separator_thin":              LegoSeparatorThin,
		"lower_left_triangle":              LowerLeftTriangle,
		"lower_right_triangle":             LowerRightTriangle,
		"pixelated_squares_big":            PixelatedSquaresBig,
		"pixelated_squares_big_mirrored":   PixelatedSquaresBigMirrored,
		"pixelated_squares_small":          PixelatedSquaresSmall,
		"pixelated_squares_small_mirrored": PixelatedSquaresSmallMirrored,
		"right_half_circle_thick":          RightHalfCircleThick,
		"right_half_circle_thin":           RightHalfCircleThin,
		"right_hard_divider_inverse":       RightHardDividerInverse,
		"trapezoid_top_bottom":             TrapezoidTopBottom,
		"trapezoid_top_bottom_mirrored":    TrapezoidTopBottomMirrored,
		"upper_left_triangle":              UpperLeftTriangle,
		"upper_right_triangle":             UpperRightTriangle,
	}
)

// AllGlyphs returns an iterator over all the glyphs in the ple class,
// returned in no particular order.
func AllGlyphs() iter.Seq[nf.Glyph] {
	return maps.Values(allGlyphs)
}

// ByID finds a glyph by its short or full ID within the class, or an empty string
// if the glyph is not found.
func ByID(id string) nf.Glyph {
	if glyph, ok := allGlyphs[id]; ok {
		return glyph
	}
	if _, stripped, ok := strings.Cut(id, string(Class)+"-"); ok {
		if glyph, gok := allGlyphs[stripped]; gok {
			return glyph
		}
	}
	return ""
}

// AllGlyphIDs returns an iterator over all the IDs of the glyphs in the class,
// returned in no particular order.
func AllGlyphIDs() iter.Seq[string] {
	return maps.Keys(allGlyphs)
}

// AllGlyphFullIDs returns an iterator over all the full IDs of the glyphs in
// the class, returned in no particular order.
func AllGlyphFullIDs() iter.Seq[string] {
	return func(yield func(string) bool) {
		for id := range allGlyphs {
			if !yield(string(Class) + "-" + id) {
				return
			}
		}
	}
}
