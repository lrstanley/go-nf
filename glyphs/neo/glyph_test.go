// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// Code generated by cmd/codegen. DO NOT EDIT.

package neo

import (
	"testing"
)

const (
	desktopEnvCount = 8
	fileExtCount    = 486
	filenameCount   = 215
	osCount         = 60
	wmCount         = 12
)

func TestDesktopEnvironments(t *testing.T) {
	t.Parallel()

	n := 0
	for range DesktopEnvironments() {
		n++
	}
	if n != desktopEnvCount {
		t.Errorf("expected %d desktop environments (from codegen), got %d", desktopEnvCount, n)
	}
	if n == 0 {
		t.Errorf("expected at least one desktop environment, got %d", n)
	}
}

func TestByDesktopEnvironment(t *testing.T) {
	t.Parallel()

	r := ByDesktopEnvironment("budgie")
	if r == nil {
		t.Errorf("expected result for known desktop environment, got nil")
	} else {
		if r.Name() == "" {
			t.Errorf("expected non-empty name, got %q", r.Name())
		}
		if r.String() == "" {
			t.Errorf("expected non-empty glyph string, got %q", r.String())
		}
		if r.Color(true) == nil {
			t.Errorf("expected non-nil dark color")
		}
		if r.Color(false) == nil {
			t.Errorf("expected non-nil light color")
		}
	}

	if r := ByDesktopEnvironment("nonexistent"); r != nil {
		t.Errorf("expected nil for nonexistent desktop environment, got %v", r)
	}
}

func TestFileExtensions(t *testing.T) {
	t.Parallel()

	n := 0
	for range FileExtensions() {
		n++
	}
	if n != fileExtCount {
		t.Errorf("expected %d file extensions (from codegen), got %d", fileExtCount, n)
	}
	if n == 0 {
		t.Errorf("expected at least one file extension, got %d", n)
	}
}

func TestByFileExtension(t *testing.T) {
	t.Parallel()

	r := ByFileExtension("3gp")
	if r == nil {
		t.Errorf("expected result for known file extension, got nil")
	} else {
		if r.Name() == "" {
			t.Errorf("expected non-empty name, got %q", r.Name())
		}
		if r.String() == "" {
			t.Errorf("expected non-empty glyph string, got %q", r.String())
		}
	}

	if r := ByFileExtension("nonexistent"); r != nil {
		t.Errorf("expected nil for nonexistent file extension, got %v", r)
	}
}

func TestFileNames(t *testing.T) {
	t.Parallel()

	n := 0
	for range FileNames() {
		n++
	}
	if n != filenameCount {
		t.Errorf("expected %d file names (from codegen), got %d", filenameCount, n)
	}
	if n == 0 {
		t.Errorf("expected at least one file name, got %d", n)
	}
}

func TestByFileName(t *testing.T) {
	t.Parallel()

	var r Result
	for name := range FileNames() {
		r = ByFileName(name)
		if r != nil {
			break
		}
	}
	if r == nil {
		t.Errorf("expected result for known file name, got nil")
	} else {
		if r.Name() == "" {
			t.Errorf("expected non-empty name, got %q", r.Name())
		}
		if r.String() == "" {
			t.Errorf("expected non-empty glyph string, got %q", r.String())
		}
	}

	if r := ByFileName("nonexistent"); r != nil {
		t.Errorf("expected nil for nonexistent file name, got %v", r)
	}
}

func TestByPath(t *testing.T) {
	t.Parallel()

	ext := "3gp"
	r := ByPath("file." + ext)
	if r == nil {
		t.Errorf("expected result for path with known extension, got nil")
	}

	var r2 Result
	for name := range FileNames() {
		r2 = ByPath("/some/path/" + name)
		if r2 != nil {
			break
		}
	}
	if r2 == nil {
		t.Errorf("expected result for path with known file name, got nil")
	}

	if r := ByPath("file.nonexistent"); r != nil {
		t.Errorf("expected nil for path with nonexistent extension, got %v", r)
	}
}

func TestOperatingSystems(t *testing.T) {
	t.Parallel()

	n := 0
	for range OperatingSystems() {
		n++
	}
	if n != osCount {
		t.Errorf("expected %d operating systems (from codegen), got %d", osCount, n)
	}
	if n == 0 {
		t.Errorf("expected at least one operating system, got %d", n)
	}
}

func TestByOperatingSystem(t *testing.T) {
	t.Parallel()

	r := ByOperatingSystem("alma")
	if r == nil {
		t.Errorf("expected result for known operating system, got nil")
	} else {
		if r.Name() == "" {
			t.Errorf("expected non-empty name, got %q", r.Name())
		}
		if r.String() == "" {
			t.Errorf("expected non-empty glyph string, got %q", r.String())
		}
	}

	if r := ByOperatingSystem("nonexistent"); r != nil {
		t.Errorf("expected nil for nonexistent operating system, got %v", r)
	}
}

func TestWindowManagers(t *testing.T) {
	t.Parallel()

	n := 0
	for range WindowManagers() {
		n++
	}
	if n != wmCount {
		t.Errorf("expected %d window managers (from codegen), got %d", wmCount, n)
	}
	if n == 0 {
		t.Errorf("expected at least one window manager, got %d", n)
	}
}

func TestByWindowManager(t *testing.T) {
	t.Parallel()

	r := ByWindowManager("awesomewm")
	if r == nil {
		t.Errorf("expected result for known window manager, got nil")
	} else {
		if r.Name() == "" {
			t.Errorf("expected non-empty name, got %q", r.Name())
		}
		if r.String() == "" {
			t.Errorf("expected non-empty glyph string, got %q", r.String())
		}
	}

	if r := ByWindowManager("nonexistent"); r != nil {
		t.Errorf("expected nil for nonexistent window manager, got %v", r)
	}
}
