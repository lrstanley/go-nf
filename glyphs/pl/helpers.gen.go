// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// Code generated by cmd/codegen. DO NOT EDIT.

package pl

import (
	"iter"
	"slices"

	"github.com/lrstanley/go-nf"
)

var allGlyphs = []*nf.Glyph{
	Branch,
	CurrentLine,
	Hostname,
	LeftHardDivider,
	LeftSoftDivider,
	LineNumber,
	Readonly,
	RightHardDivider,
	RightSoftDivider,
}

// AllGlyphs returns an iterator over all the glyphs in the pl class.
func AllGlyphs() iter.Seq[*nf.Glyph] {
	return slices.Values(allGlyphs)
}

// ByID finds a glyph by its ID within the class.
func ByID(id string) *nf.Glyph {
	switch id {
	case "branch", "pl-branch":
		return Branch
	case "current_line", "pl-current_line":
		return CurrentLine
	case "hostname", "pl-hostname":
		return Hostname
	case "left_hard_divider", "pl-left_hard_divider":
		return LeftHardDivider
	case "left_soft_divider", "pl-left_soft_divider":
		return LeftSoftDivider
	case "line_number", "pl-line_number":
		return LineNumber
	case "readonly", "pl-readonly":
		return Readonly
	case "right_hard_divider", "pl-right_hard_divider":
		return RightHardDivider
	case "right_soft_divider", "pl-right_soft_divider":
		return RightSoftDivider
	default:
		return nil
	}
}

// AllGlyphIDs returns an iterator over all the IDs of the glyphs in the class.
func AllGlyphIDs() iter.Seq[string] {
	return func(yield func(string) bool) {
		for glyph := range AllGlyphs() {
			if !yield(glyph.ID) {
				return
			}
		}
	}
}

// AllGlyphFullIDs returns an iterator over all the full IDs of the glyphs in the class.
func AllGlyphFullIDs() iter.Seq[string] {
	return func(yield func(string) bool) {
		for glyph := range AllGlyphs() {
			if !yield(glyph.FullID()) {
				return
			}
		}
	}
}
