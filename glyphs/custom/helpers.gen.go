// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// Code generated by cmd/codegen. DO NOT EDIT.

package custom

import (
	"iter"
	"maps"
	"strings"

	"github.com/lrstanley/go-nf"
)

var (
	allGlyphs = map[string]nf.Glyph{
		"ada":               Ada,
		"asm":               Asm,
		"astro":             Astro,
		"bazel":             Bazel,
		"c":                 C,
		"chuck":             Chuck,
		"common_lisp":       CommonLisp,
		"cpp":               Cpp,
		"crystal":           Crystal,
		"css":               Css,
		"default":           Default,
		"electron":          Electron,
		"elixir":            Elixir,
		"elm":               Elm,
		"emacs":             Emacs,
		"fennel":            Fennel,
		"firebase":          Firebase,
		"folder":            Folder,
		"folder_config":     FolderConfig,
		"folder_git":        FolderGit,
		"folder_git_branch": FolderGitBranch,
		"folder_github":     FolderGithub,
		"folder_npm":        FolderNpm,
		"folder_oct":        FolderOct,
		"folder_open":       FolderOpen,
		"go":                Go,
		"home":              Home,
		"kotlin":            Kotlin,
		"msdos":             Msdos,
		"neovim":            Neovim,
		"orgmode":           Orgmode,
		"play_arrow":        PlayArrow,
		"prettier":          Prettier,
		"puppet":            Puppet,
		"purescript":        Purescript,
		"ruby":              Ruby,
		"scheme":            Scheme,
		"toml":              Toml,
		"v_lang":            VLang,
		"vim":               Vim,
		"vitruvian":         Vitruvian,
		"windows":           Windows,
	}
)

// AllGlyphs returns an iterator over all the glyphs in the custom class,
// returned in no particular order.
func AllGlyphs() iter.Seq[nf.Glyph] {
	return maps.Values(allGlyphs)
}

// ByID finds a glyph by its short or full ID within the class, or an empty string
// if the glyph is not found.
func ByID(id string) nf.Glyph {
	if glyph, ok := allGlyphs[id]; ok {
		return glyph
	}
	if _, stripped, ok := strings.Cut(id, string(Class)+"-"); ok {
		if glyph, gok := allGlyphs[stripped]; gok {
			return glyph
		}
	}
	return ""
}

// AllGlyphIDs returns an iterator over all the IDs of the glyphs in the class,
// returned in no particular order.
func AllGlyphIDs() iter.Seq[string] {
	return maps.Keys(allGlyphs)
}

// AllGlyphFullIDs returns an iterator over all the full IDs of the glyphs in
// the class, returned in no particular order.
func AllGlyphFullIDs() iter.Seq[string] {
	return func(yield func(string) bool) {
		for id := range allGlyphs {
			if !yield(string(Class) + "-" + id) {
				return
			}
		}
	}
}
