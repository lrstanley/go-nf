// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// Code generated by cmd/codegen. DO NOT EDIT.

// Package all contains helpers which are applicable to all glyphs.
package all

import (
	"iter"
	"slices"

	"github.com/lrstanley/go-nf"
	"github.com/lrstanley/go-nf/glyphs/cod"
	"github.com/lrstanley/go-nf/glyphs/custom"
	"github.com/lrstanley/go-nf/glyphs/dev"
	"github.com/lrstanley/go-nf/glyphs/extra"
	"github.com/lrstanley/go-nf/glyphs/fa"
	"github.com/lrstanley/go-nf/glyphs/fae"
	"github.com/lrstanley/go-nf/glyphs/iec"
	"github.com/lrstanley/go-nf/glyphs/indent"
	"github.com/lrstanley/go-nf/glyphs/indentation"
	"github.com/lrstanley/go-nf/glyphs/linux"
	"github.com/lrstanley/go-nf/glyphs/md"
	"github.com/lrstanley/go-nf/glyphs/oct"
	"github.com/lrstanley/go-nf/glyphs/pl"
	"github.com/lrstanley/go-nf/glyphs/ple"
	"github.com/lrstanley/go-nf/glyphs/pom"
	"github.com/lrstanley/go-nf/glyphs/seti"
	"github.com/lrstanley/go-nf/glyphs/weather"
)

const (
	// Version is the version of the Nerd Fonts project which this package was generated from.
	Version = "3.4.0"
)

var classNames = []string{
	cod.ClassName,
	custom.ClassName,
	dev.ClassName,
	extra.ClassName,
	fa.ClassName,
	fae.ClassName,
	iec.ClassName,
	indent.ClassName,
	indentation.ClassName,
	linux.ClassName,
	md.ClassName,
	oct.ClassName,
	pl.ClassName,
	ple.ClassName,
	pom.ClassName,
	seti.ClassName,
	weather.ClassName,
}

// Classes returns an iterator over all the class names.
func Classes() iter.Seq[string] {
	return slices.Values(classNames)
}

// Glyphs returns an iterator over all the glyphs.
func Glyphs() iter.Seq[*nf.Glyph] {
	return func(yield func(*nf.Glyph) bool) {
		for glyph := range cod.AllGlyphs() {
			if !yield(glyph) {
				return
			}
		}
		for glyph := range custom.AllGlyphs() {
			if !yield(glyph) {
				return
			}
		}
		for glyph := range dev.AllGlyphs() {
			if !yield(glyph) {
				return
			}
		}
		for glyph := range extra.AllGlyphs() {
			if !yield(glyph) {
				return
			}
		}
		for glyph := range fa.AllGlyphs() {
			if !yield(glyph) {
				return
			}
		}
		for glyph := range fae.AllGlyphs() {
			if !yield(glyph) {
				return
			}
		}
		for glyph := range iec.AllGlyphs() {
			if !yield(glyph) {
				return
			}
		}
		for glyph := range indent.AllGlyphs() {
			if !yield(glyph) {
				return
			}
		}
		for glyph := range indentation.AllGlyphs() {
			if !yield(glyph) {
				return
			}
		}
		for glyph := range linux.AllGlyphs() {
			if !yield(glyph) {
				return
			}
		}
		for glyph := range md.AllGlyphs() {
			if !yield(glyph) {
				return
			}
		}
		for glyph := range oct.AllGlyphs() {
			if !yield(glyph) {
				return
			}
		}
		for glyph := range pl.AllGlyphs() {
			if !yield(glyph) {
				return
			}
		}
		for glyph := range ple.AllGlyphs() {
			if !yield(glyph) {
				return
			}
		}
		for glyph := range pom.AllGlyphs() {
			if !yield(glyph) {
				return
			}
		}
		for glyph := range seti.AllGlyphs() {
			if !yield(glyph) {
				return
			}
		}
		for glyph := range weather.AllGlyphs() {
			if !yield(glyph) {
				return
			}
		}
	}
}

// ByClass returns an iterator over all the glyphs in the given class, or nil if
// the class is not found.
func ByClass(class string) iter.Seq[*nf.Glyph] {
	switch class {
	case cod.ClassName:
		return cod.AllGlyphs()
	case custom.ClassName:
		return custom.AllGlyphs()
	case dev.ClassName:
		return dev.AllGlyphs()
	case extra.ClassName:
		return extra.AllGlyphs()
	case fa.ClassName:
		return fa.AllGlyphs()
	case fae.ClassName:
		return fae.AllGlyphs()
	case iec.ClassName:
		return iec.AllGlyphs()
	case indent.ClassName:
		return indent.AllGlyphs()
	case indentation.ClassName:
		return indentation.AllGlyphs()
	case linux.ClassName:
		return linux.AllGlyphs()
	case md.ClassName:
		return md.AllGlyphs()
	case oct.ClassName:
		return oct.AllGlyphs()
	case pl.ClassName:
		return pl.AllGlyphs()
	case ple.ClassName:
		return ple.AllGlyphs()
	case pom.ClassName:
		return pom.AllGlyphs()
	case seti.ClassName:
		return seti.AllGlyphs()
	case weather.ClassName:
		return weather.AllGlyphs()
	default:
		return nil
	}
}

// ByID finds a glyph by its ID across all classes.
func ByID(id string) *nf.Glyph {
	if glyph := cod.ByID(id); glyph != nil {
		return glyph
	}
	if glyph := custom.ByID(id); glyph != nil {
		return glyph
	}
	if glyph := dev.ByID(id); glyph != nil {
		return glyph
	}
	if glyph := extra.ByID(id); glyph != nil {
		return glyph
	}
	if glyph := fa.ByID(id); glyph != nil {
		return glyph
	}
	if glyph := fae.ByID(id); glyph != nil {
		return glyph
	}
	if glyph := iec.ByID(id); glyph != nil {
		return glyph
	}
	if glyph := indent.ByID(id); glyph != nil {
		return glyph
	}
	if glyph := indentation.ByID(id); glyph != nil {
		return glyph
	}
	if glyph := linux.ByID(id); glyph != nil {
		return glyph
	}
	if glyph := md.ByID(id); glyph != nil {
		return glyph
	}
	if glyph := oct.ByID(id); glyph != nil {
		return glyph
	}
	if glyph := pl.ByID(id); glyph != nil {
		return glyph
	}
	if glyph := ple.ByID(id); glyph != nil {
		return glyph
	}
	if glyph := pom.ByID(id); glyph != nil {
		return glyph
	}
	if glyph := seti.ByID(id); glyph != nil {
		return glyph
	}
	if glyph := weather.ByID(id); glyph != nil {
		return glyph
	}
	return nil
}

// GlyphIDs returns an iterator over all the IDs of the glyphs across all classes.
func GlyphIDs() iter.Seq[string] {
	return func(yield func(string) bool) {
		for glyph := range Glyphs() {
			if !yield(glyph.ID) {
				return
			}
		}
	}
}

// GlyphFullIDs returns an iterator over all the full IDs of the glyphs across all classes.
func GlyphFullIDs() iter.Seq[string] {
	return func(yield func(string) bool) {
		for glyph := range Glyphs() {
			if !yield(glyph.FullID()) {
				return
			}
		}
	}
}
