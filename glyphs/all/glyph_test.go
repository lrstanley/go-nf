// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// Code generated by cmd/codegen. DO NOT EDIT.

package all

import (
	"slices"
	"testing"

	"github.com/lrstanley/go-nf"
)

const (
	glyphCount = 10764
	classCount = 17
)

func TestClasses(t *testing.T) {
	t.Parallel()

	results := slices.Collect(Classes())

	if len(results) != classCount {
		t.Errorf("expected %d classes (from classCount), got %d", classCount, len(results))
	}

	if len(results) == 0 {
		t.Errorf("expected at least one class, got %d", len(results))
	}
	if !slices.Contains(results, "cod") {
		t.Errorf("expected class %q, got %q", "cod", results)
	}
	if !slices.Contains(results, "custom") {
		t.Errorf("expected class %q, got %q", "custom", results)
	}
	if !slices.Contains(results, "dev") {
		t.Errorf("expected class %q, got %q", "dev", results)
	}
	if !slices.Contains(results, "extra") {
		t.Errorf("expected class %q, got %q", "extra", results)
	}
	if !slices.Contains(results, "fa") {
		t.Errorf("expected class %q, got %q", "fa", results)
	}
	if !slices.Contains(results, "fae") {
		t.Errorf("expected class %q, got %q", "fae", results)
	}
	if !slices.Contains(results, "iec") {
		t.Errorf("expected class %q, got %q", "iec", results)
	}
	if !slices.Contains(results, "indent") {
		t.Errorf("expected class %q, got %q", "indent", results)
	}
	if !slices.Contains(results, "indentation") {
		t.Errorf("expected class %q, got %q", "indentation", results)
	}
	if !slices.Contains(results, "linux") {
		t.Errorf("expected class %q, got %q", "linux", results)
	}
	if !slices.Contains(results, "md") {
		t.Errorf("expected class %q, got %q", "md", results)
	}
	if !slices.Contains(results, "oct") {
		t.Errorf("expected class %q, got %q", "oct", results)
	}
	if !slices.Contains(results, "pl") {
		t.Errorf("expected class %q, got %q", "pl", results)
	}
	if !slices.Contains(results, "ple") {
		t.Errorf("expected class %q, got %q", "ple", results)
	}
	if !slices.Contains(results, "pom") {
		t.Errorf("expected class %q, got %q", "pom", results)
	}
	if !slices.Contains(results, "seti") {
		t.Errorf("expected class %q, got %q", "seti", results)
	}
	if !slices.Contains(results, "weather") {
		t.Errorf("expected class %q, got %q", "weather", results)
	}
}

func TestAllGlyphs(t *testing.T) {
	t.Parallel()

	results := slices.Collect(Glyphs())

	if len(results) != glyphCount {
		t.Errorf("expected %d glyphs (from codegen), got %d", glyphCount, len(results))
	}

	if len(results) == 0 {
		t.Errorf("expected at least one glyph, got %d", len(results))
	}

	for _, glyph := range results {
		if glyph == "" {
			t.Errorf("expected non-empty glyph, got %q", glyph)
		}
	}
}

func TestByClass(t *testing.T) {
	t.Parallel()

	for class := range Classes() {
		results := slices.Collect(ByClass(class))
		if len(results) == 0 {
			t.Errorf("expected at least one glyph for class %q, got %d", class, len(results))
		}
	}

	if c := len(slices.Collect(ByClass("nonexistent"))); c != 0 {
		t.Errorf("expected empty iterator for nonexistent class, got %d", c)
	}
}

func TestByID(t *testing.T) {
	t.Parallel()

	for class := range Classes() {
		for gid := range GlyphIDsByClass(class) {
			if glyph := ByID(gid); glyph == "" {
				t.Errorf("expected glyph for ID %q, got empty string", gid)
			}
			if glyph := ByID(string(class) + "-" + gid); glyph == "" {
				t.Errorf("expected glyph for ID %q, got empty string", string(class)+"-"+gid)
			}
		}
	}

	if c := len(slices.Collect(GlyphIDsByClass(nf.Class("nonexistent")))); c != 0 {
		t.Errorf("expected empty iterator for nonexistent class, got %d", c)
	}
}

func TestGlyphIDs(t *testing.T) {
	t.Parallel()

	results := slices.Collect(GlyphIDs())
	if len(results) != glyphCount {
		t.Errorf("expected %d glyph IDs (from codegen), got %d", glyphCount, len(results))
	}
}

func TestGlyphFullIDs(t *testing.T) {
	t.Parallel()

	results := slices.Collect(GlyphFullIDs())
	if len(results) != glyphCount {
		t.Errorf("expected %d glyph full IDs (from codegen), got %d", glyphCount, len(results))
	}

	for class := range Classes() {
		for fid := range GlyphFullIDsByClass(class) {
			if glyph := ByID(fid); glyph == "" {
				t.Errorf("expected glyph for full ID %q, got empty string", fid)
			}
		}
	}

	if c := len(slices.Collect(GlyphFullIDsByClass("nonexistent"))); c != 0 {
		t.Errorf("expected empty iterator for nonexistent class, got %d", c)
	}
}
