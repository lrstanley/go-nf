// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"text/template"
	"time"

	"github.com/lmittmann/tint"
)

const (
	packageName  = "github.com/lrstanley/go-nf"
	glyphDataURL = "https://github.com/ryanoasis/nerd-fonts/raw/refs/tags/v3.4.0/glyphnames.json"
)

var (
	logger = slog.New(tint.NewHandler(os.Stderr, &tint.Options{
		Level:      slog.LevelDebug,
		AddSource:  true,
		TimeFormat: time.RFC3339,
	}))

	funcMap = template.FuncMap{
		"header": func() string { return header },
		"quote": func(s string) string {
			return fmt.Sprintf("%q", s)
		},
	}
	constantsTmpl = template.Must(
		template.New("constants.gotmpl").
			Funcs(funcMap).
			ParseFiles("templates/constants.gotmpl"),
	)
	allGlyphsHelpersTmpl = template.Must(
		template.New("all_glyphs_helpers.gotmpl").
			Funcs(funcMap).
			ParseFiles("templates/all_glyphs_helpers.gotmpl"),
	)
	classGlyphsTmpl = template.Must(
		template.New("class_glyphs.gotmpl").
			Funcs(funcMap).
			ParseFiles("templates/class_glyphs.gotmpl"),
	)
	classHelpersTmpl = template.Must(
		template.New("class_helpers.gotmpl").
			Funcs(funcMap).
			ParseFiles("templates/class_helpers.gotmpl"),
	)

	header = `// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// Code generated by cmd/codegen. DO NOT EDIT.`
)

func main() {
	if len(os.Args) != 2 {
		logger.Error("usage", "error", "output_dir is required") //nolint:all
		os.Exit(1)
	}

	ctx, _ := signal.NotifyContext(context.Background(), os.Interrupt)

	data, err := fetchData(ctx)
	if err != nil {
		logger.Error("failed to fetch data", "error", err) //nolint:all
		os.Exit(1)
	}

	generateFile(filepath.Join(os.Args[1], "constants.gen.go"), constantsTmpl, map[string]any{
		"PackageName": packageName,
		"Metadata":    data.Metadata,
		"Classes":     data.Classes(),
	})

	generateFile(filepath.Join(os.Args[1], "glyphs", "all", "helpers.gen.go"), allGlyphsHelpersTmpl, map[string]any{
		"PackageName": packageName,
		"Metadata":    data.Metadata,
		"Classes":     data.Classes(),
	})

	for _, class := range data.Classes() {
		generateFile(filepath.Join(os.Args[1], "glyphs", class, "glyphs.gen.go"), classGlyphsTmpl, map[string]any{
			"PackageName": packageName,
			"Metadata":    data.Metadata,
			"Class":       class,
			"Glyphs":      data.Glyphs[class],
		})
		generateFile(filepath.Join(os.Args[1], "glyphs", class, "helpers.gen.go"), classHelpersTmpl, map[string]any{
			"PackageName": packageName,
			"Metadata":    data.Metadata,
			"Class":       class,
			"Glyphs":      data.Glyphs[class],
		})
	}
}

func fetchData(ctx context.Context) (*Data, error) {
	data := &Data{}

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, glyphDataURL, http.NoBody)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	var resp *http.Response
	resp, err = http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch data: %w", err)
	}
	defer resp.Body.Close()

	var b []byte
	b, err = io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read data: %w", err)
	}

	err = json.Unmarshal(b, data)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal data: %w", err)
	}

	return data, nil
}

func generateFile(path string, tmpl *template.Template, data any) {
	if err := os.MkdirAll(filepath.Dir(path), 0o750); err != nil {
		panic(err)
	}

	f, err := os.Create(path)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	err = tmpl.Execute(f, data)
	if err != nil {
		panic(err)
	}

	logger.Info("generated file", "file", path) //nolint:all
}
