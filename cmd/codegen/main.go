// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.

package main

import (
	"context"
	"fmt"
	"log/slog"
	"os"
	"os/signal"
	"path/filepath"
	"slices"
	"text/template"
	"time"

	"github.com/lmittmann/tint"
	"github.com/lrstanley/x/http/utils/httpclog"
	"github.com/lucasb-eyer/go-colorful"
)

const (
	packageName  = "github.com/lrstanley/go-nf"
	glyphDataURL = "https://github.com/ryanoasis/nerd-fonts/raw/refs/tags/v3.4.0/glyphnames.json"
)

var (
	logger = slog.New(tint.NewHandler(os.Stderr, &tint.Options{
		Level:      slog.LevelDebug,
		AddSource:  true,
		TimeFormat: time.RFC3339,
	}))

	httpClient = httpclog.NewClient(&httpclog.Config{
		Logger: logger,
		Level:  new(slog.LevelInfo),
	})

	funcMap = template.FuncMap{
		"header": func() string { return header },
		"quote": func(s string) string {
			return fmt.Sprintf("%q", s)
		},
		"hex_to_rgba": func(hex string) string {
			// colorfuls library handles 4-length hex colors, in addition to 7-length (accounting for "#").
			c, err := colorful.Hex(hex)
			if err != nil {
				return "nil"
			}
			return fmt.Sprintf("&color.RGBA{R: %d, G: %d, B: %d, A: %d}", int(c.R*255), int(c.G*255), int(c.B*255), 255)
		},
	}
	_templates = template.Must(
		template.New("").
			Funcs(funcMap).
			ParseGlob("templates/*.gotmpl"),
	)

	header = `// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// Code generated by cmd/codegen. DO NOT EDIT.`
)

func main() {
	if len(os.Args) != 2 {
		logger.Error("usage", "error", "output_dir is required") //nolint:all
		os.Exit(1)
	}

	ctx, _ := signal.NotifyContext(context.Background(), os.Interrupt)

	glyphData, err := fetchGlyphData(ctx)
	if err != nil {
		logger.Error("failed to fetch data", "error", err) //nolint:all
		os.Exit(1)
	}

	neoGlyphData, err := FetchNeoGlyphData(ctx, glyphData)
	if err != nil {
		logger.Error("failed to fetch nvim-tree icon data", "error", err) //nolint:all
		os.Exit(1)
	}

	generateFile("constants.gotmpl", filepath.Join(os.Args[1], "constants.gen.go"), map[string]any{
		"PackageName": packageName,
		"Metadata":    glyphData.Metadata,
		"Classes":     glyphData.Classes(),
	})

	allGlyphsFiles := map[string]string{
		"all_glyphs_helpers.gotmpl": "helpers.gen.go",
		"all_glyphs_test.gotmpl":    "glyphs_test.go",
	}

	for tmpl, destFile := range allGlyphsFiles {
		generateFile(tmpl, filepath.Join(os.Args[1], "glyphs", "all", destFile), map[string]any{
			"PackageName": packageName,
			"Metadata":    glyphData.Metadata,
			"Classes":     glyphData.Classes(),
			"Glyphs":      slices.Collect(glyphData.AllIter()),
		})
	}

	perGlyphFiles := map[string]string{
		"class_glyphs.gotmpl":  "glyphs.gen.go",
		"class_helpers.gotmpl": "helpers.gen.go",
		"class_test.gotmpl":    "glyphs_test.go",
	}

	for _, class := range glyphData.Classes() {
		for tmpl, destFile := range perGlyphFiles {
			generateFile(tmpl, filepath.Join(os.Args[1], "glyphs", class, destFile), map[string]any{
				"PackageName": packageName,
				"Metadata":    glyphData.Metadata,
				"Class":       class,
				"Glyphs":      glyphData.Glyphs[class],
			})
		}
	}

	neoFiles := map[string]string{
		"neo.gotmpl":        "neo.gen.go",
		"neo_glyphs.gotmpl": "glyphs.gen.go",
		"neo_test.gotmpl":   "neo_test.go",
	}

	for tmpl, destFile := range neoFiles {
		generateFile(tmpl, filepath.Join(os.Args[1], "glyphs", "neo", destFile), map[string]any{
			"PackageName": packageName,
			"Data":        neoGlyphData,
		})
	}
}

func generateFile(tmpl, destPath string, data any) {
	if err := os.MkdirAll(filepath.Dir(destPath), 0o750); err != nil {
		panic(err)
	}

	f, err := os.Create(destPath)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	err = _templates.ExecuteTemplate(f, tmpl, data)
	if err != nil {
		panic(err)
	}

	logger.Info("generated file", "file", destPath) //nolint:all
}
