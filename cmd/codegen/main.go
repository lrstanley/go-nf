// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"slices"
	"text/template"
	"time"

	"github.com/lmittmann/tint"
)

const (
	packageName  = "github.com/lrstanley/go-nf"
	glyphDataURL = "https://github.com/ryanoasis/nerd-fonts/raw/refs/tags/v3.4.0/glyphnames.json"
)

var (
	logger = slog.New(tint.NewHandler(os.Stderr, &tint.Options{
		Level:      slog.LevelDebug,
		AddSource:  true,
		TimeFormat: time.RFC3339,
	}))

	funcMap = template.FuncMap{
		"header": func() string { return header },
		"quote": func(s string) string {
			return fmt.Sprintf("%q", s)
		},
	}
	_templates = template.Must(
		template.New("").
			Funcs(funcMap).
			ParseGlob("templates/*.gotmpl"),
	)

	header = `// Copyright (c) Liam Stanley <liam@liam.sh>. All rights reserved. Use of
// this source code is governed by the MIT license that can be found in
// the LICENSE file.
//
// Code generated by cmd/codegen. DO NOT EDIT.`
)

func main() {
	if len(os.Args) != 2 {
		logger.Error("usage", "error", "output_dir is required") //nolint:all
		os.Exit(1)
	}

	ctx, _ := signal.NotifyContext(context.Background(), os.Interrupt)

	data, err := fetchData(ctx)
	if err != nil {
		logger.Error("failed to fetch data", "error", err) //nolint:all
		os.Exit(1)
	}

	generateFile("constants.gotmpl", filepath.Join(os.Args[1], "constants.gen.go"), map[string]any{
		"PackageName": packageName,
		"Metadata":    data.Metadata,
		"Classes":     data.Classes(),
	})

	allGlyphsFiles := map[string]string{
		"all_glyphs_helpers.gotmpl": "helpers.gen.go",
		"all_glyphs_test.gotmpl":    "glyph_test.go",
	}

	for tmpl, destFile := range allGlyphsFiles {
		generateFile(tmpl, filepath.Join(os.Args[1], "glyphs", "all", destFile), map[string]any{
			"PackageName": packageName,
			"Metadata":    data.Metadata,
			"Classes":     data.Classes(),
			"Glyphs":      slices.Collect(data.AllIter()),
		})
	}

	perGlyphFiles := map[string]string{
		"class_glyphs.gotmpl":  "glyphs.gen.go",
		"class_helpers.gotmpl": "helpers.gen.go",
		"class_test.gotmpl":    "glyph_test.go",
	}

	for _, class := range data.Classes() {
		for tmpl, destFile := range perGlyphFiles {
			generateFile(tmpl, filepath.Join(os.Args[1], "glyphs", class, destFile), map[string]any{
				"PackageName": packageName,
				"Metadata":    data.Metadata,
				"Class":       class,
				"Glyphs":      data.Glyphs[class],
			})
		}
	}
}

func fetchData(ctx context.Context) (*Data, error) {
	data := &Data{}

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, glyphDataURL, http.NoBody)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	var resp *http.Response
	resp, err = http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch data: %w", err)
	}
	defer resp.Body.Close()

	var b []byte
	b, err = io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read data: %w", err)
	}

	err = json.Unmarshal(b, data)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal data: %w", err)
	}

	return data, nil
}

func generateFile(tmpl, destPath string, data any) {
	if err := os.MkdirAll(filepath.Dir(destPath), 0o750); err != nil {
		panic(err)
	}

	f, err := os.Create(destPath)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	err = _templates.ExecuteTemplate(f, tmpl, data)
	if err != nil {
		panic(err)
	}

	logger.Info("generated file", "file", destPath) //nolint:all
}
