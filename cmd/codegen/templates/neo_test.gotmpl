{{ header }}

package neo

import (
    "testing"
)

const (
    desktopEnvCount = {{ len .Data.DesktopEnvironments }}
    fileExtCount    = {{ len .Data.FileExtensions }}
    filenameCount   = {{ len .Data.Filenames }}
    osCount         = {{ len .Data.OperatingSystems }}
    wmCount         = {{ len .Data.WindowManagers }}
)

func TestDesktopEnvironments(t *testing.T) {
    t.Parallel()

    n := 0
    for range DesktopEnvironments() {
        n++
    }
    if n != desktopEnvCount {
        t.Errorf("expected %d desktop environments (from codegen), got %d", desktopEnvCount, n)
    }
    if n == 0 {
        t.Errorf("expected at least one desktop environment, got %d", n)
    }
}

func TestByDesktopEnvironment(t *testing.T) {
    t.Parallel()

    r := ByDesktopEnvironment({{ (index .Data.DesktopEnvironments 0).Matcher | quote }})
    if r == nil {
        t.Errorf("expected result for known desktop environment, got nil")
    } else {
        if r.Name() == "" {
            t.Errorf("expected non-empty name, got %q", r.Name())
        }
        if r.String() == "" {
            t.Errorf("expected non-empty glyph string, got %q", r.String())
        }
        if r.Color(true) == nil {
            t.Errorf("expected non-nil dark color")
        }
        if r.Color(false) == nil {
            t.Errorf("expected non-nil light color")
        }
    }

    if r := ByDesktopEnvironment("nonexistent"); r != nil {
        t.Errorf("expected nil for nonexistent desktop environment, got %v", r)
    }
}

func TestFileExtensions(t *testing.T) {
    t.Parallel()

    n := 0
    for range FileExtensions() {
        n++
    }
    if n != fileExtCount {
        t.Errorf("expected %d file extensions (from codegen), got %d", fileExtCount, n)
    }
    if n == 0 {
        t.Errorf("expected at least one file extension, got %d", n)
    }
}

func TestByFileExtension(t *testing.T) {
    t.Parallel()

    r := ByFileExtension({{ (index .Data.FileExtensions 0).Matcher | quote }})
    if r == nil {
        t.Errorf("expected result for known file extension, got nil")
    } else {
        if r.Name() == "" {
            t.Errorf("expected non-empty name, got %q", r.Name())
        }
        if r.String() == "" {
            t.Errorf("expected non-empty glyph string, got %q", r.String())
        }
    }

    if r := ByFileExtension("nonexistent"); r != nil {
        t.Errorf("expected nil for nonexistent file extension, got %v", r)
    }
}

func TestFileNames(t *testing.T) {
    t.Parallel()

    n := 0
    for range FileNames() {
        n++
    }
    if n != filenameCount {
        t.Errorf("expected %d file names (from codegen), got %d", filenameCount, n)
    }
    if n == 0 {
        t.Errorf("expected at least one file name, got %d", n)
    }
}

func TestByFileName(t *testing.T) {
    t.Parallel()

    var r Result
    for name := range FileNames() {
        r = ByFileName(name)
        if r != nil {
            break
        }
    }
    if r == nil {
        t.Errorf("expected result for known file name, got nil")
    } else {
        if r.Name() == "" {
            t.Errorf("expected non-empty name, got %q", r.Name())
        }
        if r.String() == "" {
            t.Errorf("expected non-empty glyph string, got %q", r.String())
        }
    }

    if r := ByFileName("nonexistent"); r != nil {
        t.Errorf("expected nil for nonexistent file name, got %v", r)
    }
}

func TestByPath(t *testing.T) {
    t.Parallel()

    ext := {{ (index .Data.FileExtensions 0).Matcher | quote }}
    r := ByPath("file." + ext)
    if r == nil {
        t.Errorf("expected result for path with known extension, got nil")
    }

    var r2 Result
    for name := range FileNames() {
        r2 = ByPath("/some/path/" + name)
        if r2 != nil {
            break
        }
    }
    if r2 == nil {
        t.Errorf("expected result for path with known file name, got nil")
    }

    if r := ByPath("file.nonexistent"); r != nil {
        t.Errorf("expected nil for path with nonexistent extension, got %v", r)
    }
}

func TestOperatingSystems(t *testing.T) {
    t.Parallel()

    n := 0
    for range OperatingSystems() {
        n++
    }
    if n != osCount {
        t.Errorf("expected %d operating systems (from codegen), got %d", osCount, n)
    }
    if n == 0 {
        t.Errorf("expected at least one operating system, got %d", n)
    }
}

func TestByOperatingSystem(t *testing.T) {
    t.Parallel()

    r := ByOperatingSystem({{ (index .Data.OperatingSystems 0).Matcher | quote }})
    if r == nil {
        t.Errorf("expected result for known operating system, got nil")
    } else {
        if r.Name() == "" {
            t.Errorf("expected non-empty name, got %q", r.Name())
        }
        if r.String() == "" {
            t.Errorf("expected non-empty glyph string, got %q", r.String())
        }
    }

    if r := ByOperatingSystem("nonexistent"); r != nil {
        t.Errorf("expected nil for nonexistent operating system, got %v", r)
    }
}

func TestWindowManagers(t *testing.T) {
    t.Parallel()

    n := 0
    for range WindowManagers() {
        n++
    }
    if n != wmCount {
        t.Errorf("expected %d window managers (from codegen), got %d", wmCount, n)
    }
    if n == 0 {
        t.Errorf("expected at least one window manager, got %d", n)
    }
}

func TestByWindowManager(t *testing.T) {
    t.Parallel()

    r := ByWindowManager({{ (index .Data.WindowManagers 0).Matcher | quote }})
    if r == nil {
        t.Errorf("expected result for known window manager, got nil")
    } else {
        if r.Name() == "" {
            t.Errorf("expected non-empty name, got %q", r.Name())
        }
        if r.String() == "" {
            t.Errorf("expected non-empty glyph string, got %q", r.String())
        }
    }

    if r := ByWindowManager("nonexistent"); r != nil {
        t.Errorf("expected nil for nonexistent window manager, got %v", r)
    }
}
