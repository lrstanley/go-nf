{{ header }}

// Package all contains helpers which are applicable to all glyphs.
package all

import (
    "iter"
    "slices"

    {{ .PackageName | quote }}
    {{- range $class := .Classes }}
    {{ printf "%s/glyphs/%s" $.PackageName $class | quote }}
    {{- end }}
)

const (
    // Version is the version of the Nerd Fonts project which this package was generated from.
    Version = {{ .Metadata.Version | quote }}
)

var classes = []nf.Class{
    {{- range $class := .Classes }}
        {{ $class }}.Class,
    {{- end }}
}

// Classes returns an iterator over all the classes.
func Classes() iter.Seq[nf.Class] {
    return slices.Values(classes)
}

// Glyphs returns an iterator over all the glyphs.
func Glyphs() iter.Seq[nf.Glyph] {
    return func(yield func(nf.Glyph) bool) {
        {{- range $class := .Classes }}
            for glyph := range {{ $class }}.AllGlyphs() {
                if !yield(glyph) {
                    return
                }
            }
        {{- end }}
    }
}

// ByClass returns an iterator over all the glyphs in the given class. If the
// class does not exist, an empty iterator is returned.
func ByClass(class nf.Class) iter.Seq[nf.Glyph] {
    switch class {
    {{- range $class := .Classes }}
    case {{ $class }}.Class:
        return {{ $class }}.AllGlyphs()
    {{- end }}
    default:
        return func(yield func(nf.Glyph) bool) {
            return
        }
    }
}

// ByID finds a glyph by its short or full ID across all classes, or an empty string
// if the glyph is not found.
func ByID(id string) nf.Glyph {
    {{- range $class := .Classes }}
        if glyph := {{ $class }}.ByID(id); glyph != "" {
            return glyph
        }
    {{- end }}
    return ""
}

// GlyphIDs returns an iterator over all the IDs of the glyphs across all classes.
func GlyphIDs() iter.Seq[string] {
    return func(yield func(string) bool) {
        {{- range $class := .Classes }}
            for id := range {{ $class }}.AllGlyphIDs() {
                if !yield(id) {
                    return
                }
            }
        {{- end }}
    }
}

// GlyphIDsByClass returns an iterator over all the IDs of the glyphs in the given
// class. If the class does not exist, an empty iterator is returned.
func GlyphIDsByClass(class nf.Class) iter.Seq[string] {
    switch class {
    {{- range $class := .Classes }}
    case {{ $class }}.Class:
        return {{ $class }}.AllGlyphIDs()
    {{- end }}
    default:
        return func(yield func(string) bool) {
            return
        }
    }
}

// GlyphFullIDs returns an iterator over all the full IDs of the glyphs across all classes.
func GlyphFullIDs() iter.Seq[string] {
    return func(yield func(string) bool) {
        {{- range $class := .Classes }}
            for id := range {{ $class }}.AllGlyphFullIDs() {
                if !yield(id) {
                    return
                }
            }
        {{- end }}
    }
}

// GlyphFullIDsByClass returns an iterator over all the full IDs of the glyphs in the given
// class. If the class does not exist, an empty iterator is returned.
func GlyphFullIDsByClass(class nf.Class) iter.Seq[string] {
    switch class {
    {{- range $class := .Classes }}
    case {{ $class }}.Class:
        return {{ $class }}.AllGlyphFullIDs()
    {{- end }}
    default:
        return func(yield func(string) bool) {
            return
        }
    }
}
